#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "win_et199.h"

#define G_BUF_SIZE 10240
unsigned char g_file_buf[G_BUF_SIZE];
unsigned char c51[927]={
    0x02,0x03,0x84,0xe4,0x90,0x00,0x00,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,
    0xa3,0xf0,0x78,0x01,0x7c,0x00,0x7d,0x01,0x7b,0x01,0x7a,0x08,0x79,0x02,0xfe,0x7f,
    0x01,0x12,0x02,0xb7,0x78,0x02,0x7c,0x00,0x7d,0x01,0x7b,0x01,0x7a,0x08,0x79,0x03,
    0x7e,0x00,0x7f,0x01,0x12,0x02,0xb7,0x78,0x03,0x7c,0x00,0x7d,0x01,0x7b,0x01,0x7a,
    0x08,0x79,0x04,0x7e,0x00,0x7f,0x02,0x12,0x02,0xb7,0x90,0x00,0x02,0xe0,0xff,0x7e,
    0x00,0x78,0x06,0x7c,0x00,0x7d,0x01,0x7b,0x01,0x7a,0x08,0x79,0x06,0x12,0x02,0xb7,
    0x90,0x00,0x01,0xe0,0x60,0x03,0x02,0x01,0x29,0x75,0x08,0x10,0x75,0x09,0x09,0x75,
    0x0a,0x01,0x75,0x0b,0x00,0x75,0x0c,0x05,0x12,0x03,0x4e,0x90,0x00,0x00,0xef,0xf0,
    0xe0,0xff,0x60,0x3f,0x64,0x05,0x70,0x26,0x75,0x08,0x10,0x75,0x09,0x09,0x75,0x0a,
    0x04,0xf5,0x0b,0x75,0x0c,0x01,0xf5,0x0d,0x75,0x0e,0x01,0x75,0x0f,0x00,0x75,0x10,
    0x05,0x12,0x02,0xdd,0x90,0x00,0x00,0xef,0xf0,0xe0,0x60,0x17,0x80,0x00,0x75,0x08,
    0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,0x0b,0x00,0x75,0x0c,0x00,0x12,0x03,0x69,
    0x12,0x03,0x9b,0x90,0x00,0x05,0xe0,0xf5,0x08,0x90,0x00,0x03,0xe0,0xf5,0x09,0xa3,
    0xe0,0xf5,0x0a,0x90,0x00,0x02,0xe0,0xf5,0x0b,0x75,0x0c,0x01,0x75,0x0d,0x00,0x75,
    0x0e,0x06,0x12,0x03,0x2b,0x90,0x00,0x00,0xef,0xf0,0xe0,0x60,0x1e,0x90,0x00,0x05,
    0xe0,0xf5,0x08,0x12,0x03,0x90,0x75,0x08,0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,
    0x0b,0x00,0x75,0x0c,0x00,0x12,0x03,0x69,0x12,0x03,0x9b,0x90,0x00,0x05,0xe0,0xf5,
    0x08,0x12,0x03,0x90,0x75,0x08,0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,0x0b,0x00,
    0x75,0x0c,0x00,0x12,0x03,0x69,0x12,0x03,0x9b,0x90,0x00,0x01,0xe0,0x64,0x01,0x60,
    0x03,0x02,0x01,0xcc,0x75,0x08,0x10,0x75,0x09,0x09,0x75,0x0a,0x01,0x75,0x0b,0x00,
    0x75,0x0c,0x05,0x12,0x03,0x4e,0x90,0x00,0x00,0xef,0xf0,0xe0,0x60,0x15,0x75,0x08,
    0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,0x0b,0x00,0x75,0x0c,0x00,0x12,0x03,0x69,
    0x12,0x03,0x9b,0x90,0x00,0x05,0xe0,0xf5,0x08,0x90,0x00,0x03,0xe0,0xf5,0x09,0xa3,
    0xe0,0xf5,0x0a,0x90,0x00,0x02,0xe0,0xf5,0x0b,0x75,0x0c,0x01,0x75,0x0d,0x00,0x75,
    0x0e,0x06,0x12,0x03,0x08,0x90,0x00,0x00,0xef,0xf0,0xe0,0x60,0x1e,0x90,0x00,0x05,
    0xe0,0xf5,0x08,0x12,0x03,0x90,0x75,0x08,0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,
    0x0b,0x00,0x75,0x0c,0x00,0x12,0x03,0x69,0x12,0x03,0x9b,0x90,0x00,0x05,0xe0,0xf5,
    0x08,0x12,0x03,0x90,0x90,0x00,0x02,0xe0,0x75,0x08,0x00,0xf5,0x09,0x75,0x0a,0x01,
    0x75,0x0b,0x00,0x75,0x0c,0x06,0x12,0x03,0x69,0x12,0x03,0x9b,0x90,0x00,0x00,0x74,
    0x88,0xf0,0x75,0x08,0x00,0x75,0x09,0x01,0x75,0x0a,0x01,0x75,0x0b,0x00,0x75,0x0c,
    0x00,0x12,0x03,0x69,0x02,0x03,0x9b,0xe7,0x09,0xf6,0x08,0xdf,0xfa,0x80,0x46,0xe7,
    0x09,0xf2,0x08,0xdf,0xfa,0x80,0x3e,0x88,0x82,0x8c,0x83,0xe7,0x09,0xf0,0xa3,0xdf,
    0xfa,0x80,0x32,0xe3,0x09,0xf6,0x08,0xdf,0xfa,0x80,0x78,0xe3,0x09,0xf2,0x08,0xdf,
    0xfa,0x80,0x70,0x88,0x82,0x8c,0x83,0xe3,0x09,0xf0,0xa3,0xdf,0xfa,0x80,0x64,0x89,
    0x82,0x8a,0x83,0xe0,0xa3,0xf6,0x08,0xdf,0xfa,0x80,0x58,0x89,0x82,0x8a,0x83,0xe0,
    0xa3,0xf2,0x08,0xdf,0xfa,0x80,0x4c,0x80,0xd2,0x80,0xfa,0x80,0xc6,0x80,0xd4,0x80,
    0x69,0x80,0xf2,0x80,0x33,0x80,0x10,0x80,0xa6,0x80,0xea,0x80,0x9a,0x80,0xa8,0x80,
    0xda,0x80,0xe2,0x80,0xca,0x80,0x33,0x89,0x82,0x8a,0x83,0xec,0xfa,0xe4,0x93,0xa3,
    0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,
    0x83,0xcc,0xdf,0xe9,0xde,0xe7,0x80,0x0d,0x89,0x82,0x8a,0x83,0xe4,0x93,0xa3,0xf6,
    0x08,0xdf,0xf9,0xec,0xfa,0xa9,0xf0,0xed,0xfb,0x22,0x89,0x82,0x8a,0x83,0xec,0xfa,
    0xe0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,
    0xcc,0xc5,0x83,0xcc,0xdf,0xea,0xde,0xe8,0x80,0xdb,0x89,0x82,0x8a,0x83,0xe4,0x93,
    0xa3,0xf2,0x08,0xdf,0xf9,0x80,0xcc,0x88,0xf0,0xef,0x60,0x01,0x0e,0x4e,0x60,0xc3,
    0x88,0xf0,0xed,0x24,0x02,0xb4,0x04,0x00,0x50,0xb9,0xf5,0x82,0xeb,0x24,0x02,0xb4,
    0x04,0x00,0x50,0xaf,0x23,0x23,0x45,0x82,0x23,0x90,0x02,0x37,0x73,0x12,0xff,0x00,
    0xe5,0x08,0x24,0x00,0xe5,0x09,0x24,0x01,0xe5,0x0a,0x24,0x02,0xe5,0x0b,0x24,0x03,
    0xe5,0x0c,0x24,0x04,0xe5,0x0d,0x24,0x05,0xe5,0x0e,0x24,0x06,0xe5,0x0f,0x24,0x07,
    0xe5,0x10,0x24,0x08,0x12,0xff,0x20,0x22,0x12,0xff,0x00,0xe5,0x08,0x24,0x00,0xe5,
    0x09,0x24,0x01,0xe5,0x0a,0x24,0x02,0xe5,0x0b,0x24,0x03,0xe5,0x0c,0x24,0x04,0xe5,
    0x0d,0x24,0x05,0xe5,0x0e,0x24,0x06,0x12,0xff,0x23,0x22,0x12,0xff,0x00,0xe5,0x08,
    0x24,0x00,0xe5,0x09,0x24,0x01,0xe5,0x0a,0x24,0x02,0xe5,0x0b,0x24,0x03,0xe5,0x0c,
    0x24,0x04,0xe5,0x0d,0x24,0x05,0xe5,0x0e,0x24,0x06,0x12,0xff,0x24,0x22,0x12,0xff,
    0x00,0xe5,0x08,0x24,0x00,0xe5,0x09,0x24,0x01,0xe5,0x0a,0x24,0x02,0xe5,0x0b,0x24,
    0x03,0xe5,0x0c,0x24,0x04,0x12,0xff,0x21,0x22,0x12,0xff,0x00,0xe5,0x08,0x24,0x00,
    0xe5,0x09,0x24,0x01,0xe5,0x0a,0x24,0x02,0xe5,0x0b,0x24,0x03,0xe5,0x0c,0x24,0x04,
    0x12,0xff,0x11,0x22,0x78,0x7f,0xe4,0xf6,0xd8,0xfd,0x75,0x81,0x10,0x02,0x00,0x03,
    0x12,0xff,0x00,0xe5,0x08,0x24,0x00,0x12,0xff,0x22,0x22,0x12,0xff,0x01,0x22};


ET_CONTEXT pContext[8];
int g_debug = 0;


int error_exit(char * Perfix, unsigned long dwErr)
{
    if (g_debug) {
        char sErr[128];
        //
        memset(sErr, 0, sizeof(sErr));
        ETFormatErrorMessage(dwErr,sErr,sizeof(sErr));
        printf("%s Error:%s\r\n",Perfix,sErr);
    }
    return dwErr;
}

void FlipBuffer(unsigned char* pBuf, unsigned long ulLen)
{
    unsigned char ucTemp;
    for(unsigned long i = 0; i < ulLen >> 1; ++i)
    {
        ucTemp = pBuf[i];
        pBuf[i] = pBuf[ulLen - i - 1];
        pBuf[ulLen - i - 1] = ucTemp;
    }
}

int dongle_write_file(int index, unsigned char *file_data, int size)
{

    unsigned char cBuffer[256] = {0};
    unsigned char cOut[256] = {0};
    unsigned long dwOutLen = 0;
    unsigned long wOffset = 10;
    int dwRet = 0;

    cBuffer[0] = 0;
    cBuffer[1] = (unsigned char)size;
    FlipBuffer((unsigned char*)&wOffset, 2);
    memcpy(cBuffer+2, &wOffset, 2);
    memcpy(cBuffer+4, file_data, size);

    dwRet = ETExecute(&pContext[index], "0001", cBuffer, 4+size, cOut, 256, &dwOutLen);
    if(dwRet) return error_exit("Execute 0001", dwRet);

    if(cOut[0] != 0)
        return -1;

    return 0;
}

int dongle_read_file(int index, unsigned char *file_data, int size)
{

    unsigned char cBuffer[256] = {0};
    unsigned long dwOutLen = 0;
    unsigned long wOffset = 10;
    int dwRet = 0;

    cBuffer[0] = 1;
    cBuffer[1] = (unsigned char)size;
    FlipBuffer((unsigned char*)&wOffset, 2);
    memcpy(cBuffer+2, &wOffset, 2);

    dwRet = ETExecute(&pContext[index], "0001", cBuffer, 4, file_data, 256, &dwOutLen);
    if(dwRet) return error_exit("Execute 0001", dwRet);

    if (dwOutLen == 1)
        return -1;

    return 0;
}

int get_device_cnt(int debug) {
    int i = 0;
    int j = 0;
    unsigned long Frq = 5;   //0.5 seconds twinkle again
    unsigned long TokenSize,DFSize;
    unsigned long dwRet;
    int  dwCount = 0;
    int fsize = 0;

    g_debug = debug;

    dwRet = ETEnum(0, &dwCount);
    if(dwRet != ET_E_INSUFFICIENT_BUFFER && dwRet) {
        return error_exit("ETEnum 1", dwRet);
    }

    memset(pContext, 0, sizeof(ET_CONTEXT)*dwCount);
    dwRet = ETEnum(pContext, &dwCount);
    if(dwRet) return error_exit("ETEnum 2", dwRet);
    return dwCount;

    for (i = 0; i < dwCount; i++) {
    }

    return dwCount;
}

int open_device(int index) {
    int dwRet;
    int j = 0;
    ET_OPENINFO oinfo;
    oinfo.dwOpenInfoSize = sizeof(ET_OPENINFO);
    oinfo.dwShareMode = 1;
    dwRet = ETOpenEx(&pContext[index], &oinfo);
    if(dwRet) return error_exit("ETOpen", dwRet);

    if (g_debug) {
        printf("Open ET199[%d]: \n", index);
        printf("COS Version: %lu.%02lu\n", pContext[index].dwVersion>>8 & 0xff,
                pContext[index].dwVersion & 0xff);
        printf("HardSerial: ");
        for(j=0; j<8; j++) {
            printf("%02X", pContext[index].bID[j]);
        }
        printf("\n");
        printf("ATR:%s\n", pContext[index].bAtr);
    }
    return 0;
}

void close_device(int index) {
    ETClose(&pContext[index]);
}

int set_atr(int index, unsigned char *atr) {
    int dwRet;
    int i = 0;
    dwRet = ETChangeDir(&pContext[index], "\\");
    if (dwRet) return error_exit("ChangeDir root", dwRet);

    //Use the default developers, if not the default password verify password, here need to replace into your password
    dwRet = ETVerifyPin(&pContext[index], ET_DEFAULT_DEV_PIN, ET_DEV_PIN_LEN, ET_DEV_PIN);
    if (dwRet) return error_exit("verify default pin", dwRet);

    dwRet = ETControl(&pContext[index], ET_SET_DEVICE_ATR, atr, MAX_ATR_LEN, NULL, 0, NULL);
    if (dwRet) return error_exit("Set atr", dwRet);

    return 0;
}

int get_atr(int index, unsigned char *atr) {
    int i = 0;
    for (i = 0; i < MAX_ATR_LEN; i++) {
        atr[i] = pContext[index].bAtr[i];
    }
    return 0;
}

int get_hardware_id(int index, unsigned char *bid) {
    int i = 0;

    for(i=0; i<8; i++) {
        bid[i] = pContext[index].bID[i];
    }

    return 0;
}

int write_sign(int index, unsigned char *user_pin, unsigned char *sign, int size) {
    /* size = 128+8 : 128bytes sign + 8bytes date eg: 20210309 */
    unsigned long dwRet;

    dwRet = ETChangeDir(&pContext[index], "\\");
    if (dwRet) return error_exit("ChangeDir root", dwRet);

    //Use the default developers, if not the default password verify password, here need to replace into your password
    dwRet = ETVerifyPin(&pContext[index], ET_DEFAULT_DEV_PIN, ET_DEV_PIN_LEN, ET_DEV_PIN);
    if (dwRet) return error_exit("verify default pin", dwRet);

    //Delete the root directory
    dwRet = ETEraseDir(&pContext[index], NULL);
    if(dwRet) return error_exit("ETEraseDir", dwRet);

    //Create the root directory
    dwRet = ETCreateDir(&pContext[index], NULL, 0, ET_CREATE_ROOT_DIR);
    if(dwRet) return error_exit("CreateDir", dwRet);

    dwRet = ETVerifyPin(&pContext[index], ET_DEFAULT_DEV_PIN, ET_DEV_PIN_LEN, ET_DEV_PIN);

    dwRet = ETCreateDir(&pContext[index], "2000", 60000, ET_CREATE_SUB_DIR);
    if(dwRet) return error_exit("CreateDir 2000", dwRet);

    dwRet = ETVerifyPin(&pContext[index],ET_DEFAULT_DEV_PIN,ET_DEV_PIN_LEN,ET_DEV_PIN);

    dwRet = ETCreateFile(&pContext[index], "0001", 1024, 4);//Executable file
    if(dwRet) return error_exit("CreateFile 0001", dwRet);

    dwRet = ETWriteFile(&pContext[index],"0001",0, c51, sizeof(c51));
    if(dwRet) return error_exit("Writefile 0001", dwRet);

    dwRet = ETChangePin(&pContext[index],(unsigned char *)"12345678",8,
            user_pin,8,ET_USER_PIN,0);
    if(dwRet) return error_exit("ChangeUserPin", dwRet);

    dwRet = ETVerifyPin(&pContext[index],user_pin, 8, ET_USER_PIN);
    if(dwRet) return error_exit("VerifyPin user", dwRet);

    dwRet = dongle_write_file(index, sign, size);
    if (dwRet) return dwRet;

    return 0;
}

int read_sign(int index, unsigned char *user_pin, unsigned char *sign, int size) {
    unsigned long dwRet;

    dwRet = ETVerifyPin(&pContext[index], ET_DEFAULT_DEV_PIN, ET_DEV_PIN_LEN, ET_DEV_PIN);
    if (dwRet) return error_exit("verify default pin", dwRet);

    dwRet = ETChangeDir(&pContext[index], "\\");
    if (dwRet) return error_exit("ChangeDir root", dwRet);

    dwRet = ETVerifyPin(&pContext[index], ET_DEFAULT_DEV_PIN, ET_DEV_PIN_LEN, ET_DEV_PIN);
    if (dwRet) return error_exit("verify default pin", dwRet);

    dwRet = ETChangeDir(&pContext[index], "2000");
    if (dwRet) return error_exit("ChangeDir 2000", dwRet);

    dwRet = ETVerifyPin(&pContext[index], user_pin, 8, ET_USER_PIN);
    if(dwRet) return error_exit("VerifyPin user", dwRet);

    dwRet = dongle_read_file(index, sign, size);
    if (dwRet) return dwRet;

    return 0;
}

int read_file(const char *path_of_file, unsigned char *buf, int buf_size) {
    FILE* fp;
    int fsize;
    fp = fopen(path_of_file, "rb");  //Binary read-only
    if(fp == 0) return error_exit("open file", 0);

    fseek(fp,0,SEEK_END);
    fsize = ftell(fp);
    memset(buf, 0, buf_size);
    fseek(fp, 0, SEEK_SET);
    fread(buf, fsize, 1, fp);
    fclose(fp);
    return fsize;
}

/*
int main(int argc, char* argv[])
{
    int i = 0, j = 0;
    int cnt = 0;
    unsigned char bid[8];
    unsigned char sign[128+8+1] = "P7qvCMI9YZrwrgn4mh+jkPfqaeLYRKfNqZPyffsQnv6LH37kgmFLdvbczhZJMf1QV9lFdLWq+WiUzdJ+I+A5+q/lSxDAtQ8hjMgSwmA2jcVwCmjvVZZzsLPsJrzW0AzU20210309";

    cnt = get_device_cnt(1);

    if (argc == 2) {
        printf("test create dongle\n");
        for (i=0; i < cnt; i++) {
            open_device(i);
            get_hardware_id(i, bid);
            printf("create dongle: %d\nHid:", i);
            for(j=0; j<8; j++) {
                printf("%02X", pContext[i].bID[j]);
            }
            printf("\n");
            write_sign(i, sign, 128+8);
            close_device(i);
        }
    } else {
        printf("test verify dongle\n");
        for (i=0; i < cnt; i++) {
            open_device(i);
            get_hardware_id(i, bid);
            printf("verify dongle: %d\n:Hid", i);
            for(j=0; j<8; j++) {
                printf("%02X", pContext[i].bID[j]);
            }
            printf("\n");
            memset(sign, 0, sizeof(sign));
            read_sign(i, sign, 128+8);
            close_device(i);
            printf("sign:%s\n", sign);
        }
    }
}
*/
